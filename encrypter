use std::io;

fn swap_adjacent_characters(s: &str) -> String {
    let mut swapped = String::from(s);

    let mut chars = swapped.chars().collect::<Vec<_>>();

    for i in (0..chars.len() - 1).step_by(2) {
        chars.swap(i, i + 1);
    }

    swapped.clear();
    swapped.extend(chars);

    swapped
}

fn xor_with_key(s: &str, key: &str) -> String {
    let mut result = String::new();

    let key_chars = key.chars().cycle();
    
    for (c, k) in s.chars().zip(key_chars) {
        result.push((c as u8 ^ k as u8) as char);
    }

    result
}

fn display_in_hex(s: &str) {
    for c in s.chars() {
        print!("{:02X}", c as u8);
    }
    println!();
}

fn get_key_from_user() -> String {
    let mut key = String::new();
    io::stdin().read_line(&mut key).expect("Failed to read line");
    key.trim().to_string()
}

fn encrypt(s: &str, key: &str) -> String {
    let swapped = swap_adjacent_characters(s);
    xor_with_key(&swapped, key)
}

fn decrypt(enc: &str, key: &str) -> String {
    let dec = xor_with_key(enc, key);
    swap_adjacent_characters(&dec)
}

fn main() {
    let mut input = String::new();
    print!("Enter the original string: \n");
    
    io::stdin().read_line(&mut input).expect("Failed to read line");
    
    print!("Enter the encryption key: \n");
    let key = get_key_from_user();

    let encrypted = encrypt(&input, &key);
    println!("Encrypted string (Hex): ");
    display_in_hex(&encrypted);

    let decrypted = decrypt(&encrypted, &key);
    println!("Decrypted string: {}", decrypted);
}
